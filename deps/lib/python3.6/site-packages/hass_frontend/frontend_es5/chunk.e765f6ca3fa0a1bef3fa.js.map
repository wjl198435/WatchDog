{"version":3,"sources":["webpack:///../src/error.js","webpack:///../node_modules/kind-of/index.js","webpack:///../src/constants.js","webpack:///../src/utils.js","webpack:///../src/kinds.js","webpack:///../src/types.js","webpack:///../src/superstruct.js","webpack:///../src/index.js"],"names":["StructError","attrs","_this","_classCallCheck","this","message","data","path","value","reason","type","_attrs$errors","errors","length","push","Error","captureStackTrace","constructor","stack","TypeError","JSON","toString","Object","prototype","kindOf","val","_typeof","ctorName","Array","isArray","isBuffer","callee","err","indexOf","isArguments","Date","toDateString","getDate","setDate","isDate","stackTraceLimit","isError","RegExp","flags","ignoreCase","multiline","global","isRegexp","throw","return","next","isGeneratorObj","call","slice","toLowerCase","replace","name","IS_STRUCT","KIND","isStruct","resolveDefaults","defaults","Kind","validate","any","schema","defaults$$1","options","tuple","list","func","object","required","union","intersection","scalar","optional","concat","en","map","s","e","String","join","arguments","undefined","isValid","result","failure","_extends","array","element","_array$validate2","_slicedToArray","error","ret","_loop3","i","v","_element$validate2","r","forEach","singleE","first","obj","ks","properties","key","kind","valueKeys","propertiesKeys","Set","_kind$validate4","_e2","fn","types","_kind$validate8","kinds","k","Math","_loop5","_e3","_kind$validate10","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","done","_k2$validate2","t","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","_t$validate2","Kinds","keys","values","resolved","_loop","_k","_keys$validate2","_values$validate2","e2","r2","_loop2","_key","_kind$validate2","struct","_loop4","_key2","_kind$validate6","createSchema","_schema$validate2","Types","superstruct","config","Struct","defineProperty","assert","_kind$validate12","test","_kind$validate16","TYPES","isNaN"],"mappings":"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","file":"chunk.e765f6ca3fa0a1bef3fa.js","sourcesContent":["/**\n * Define a struct error.\n *\n * @type {StructError}\n */\n\nclass StructError extends TypeError {\n  static format(attrs) {\n    const { type, path, value } = attrs\n    const message = `Expected a value of type \\`${type}\\`${\n      path.length ? ` for \\`${path.join('.')}\\`` : ''\n    } but received \\`${JSON.stringify(value)}\\`.`\n    return message\n  }\n\n  constructor(attrs) {\n    const message = StructError.format(attrs)\n    super(message)\n\n    const { data, path, value, reason, type, errors = [] } = attrs\n    this.data = data\n    this.path = path\n    this.value = value\n    this.reason = reason\n    this.type = type\n    this.errors = errors\n\n    if (!errors.length) {\n      errors.push(this)\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor)\n    } else {\n      this.stack = new Error().stack\n    }\n  }\n}\n\n/**\n * Export.\n *\n * @type {StructError}\n */\n\nexport default StructError\n","var toString = Object.prototype.toString;\n\nmodule.exports = function kindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n\n  var type = typeof val;\n  if (type === 'boolean') return 'boolean';\n  if (type === 'string') return 'string';\n  if (type === 'number') return 'number';\n  if (type === 'symbol') return 'symbol';\n  if (type === 'function') {\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\n  }\n\n  if (isArray(val)) return 'array';\n  if (isBuffer(val)) return 'buffer';\n  if (isArguments(val)) return 'arguments';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  if (isRegexp(val)) return 'regexp';\n\n  switch (ctorName(val)) {\n    case 'Symbol': return 'symbol';\n    case 'Promise': return 'promise';\n\n    // Set, Map, WeakSet, WeakMap\n    case 'WeakMap': return 'weakmap';\n    case 'WeakSet': return 'weakset';\n    case 'Map': return 'map';\n    case 'Set': return 'set';\n\n    // 8-bit typed arrays\n    case 'Int8Array': return 'int8array';\n    case 'Uint8Array': return 'uint8array';\n    case 'Uint8ClampedArray': return 'uint8clampedarray';\n\n    // 16-bit typed arrays\n    case 'Int16Array': return 'int16array';\n    case 'Uint16Array': return 'uint16array';\n\n    // 32-bit typed arrays\n    case 'Int32Array': return 'int32array';\n    case 'Uint32Array': return 'uint32array';\n    case 'Float32Array': return 'float32array';\n    case 'Float64Array': return 'float64array';\n  }\n\n  if (isGeneratorObj(val)) {\n    return 'generator';\n  }\n\n  // Non-plain objects\n  type = toString.call(val);\n  switch (type) {\n    case '[object Object]': return 'object';\n    // iterators\n    case '[object Map Iterator]': return 'mapiterator';\n    case '[object Set Iterator]': return 'setiterator';\n    case '[object String Iterator]': return 'stringiterator';\n    case '[object Array Iterator]': return 'arrayiterator';\n  }\n\n  // other\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n};\n\nfunction ctorName(val) {\n  return val.constructor ? val.constructor.name : null;\n}\n\nfunction isArray(val) {\n  if (Array.isArray) return Array.isArray(val);\n  return val instanceof Array;\n}\n\nfunction isError(val) {\n  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function'\n    && typeof val.getDate === 'function'\n    && typeof val.setDate === 'function';\n}\n\nfunction isRegexp(val) {\n  if (val instanceof RegExp) return true;\n  return typeof val.flags === 'string'\n    && typeof val.ignoreCase === 'boolean'\n    && typeof val.multiline === 'boolean'\n    && typeof val.global === 'boolean';\n}\n\nfunction isGeneratorFn(name, val) {\n  return ctorName(name) === 'GeneratorFunction';\n}\n\nfunction isGeneratorObj(val) {\n  return typeof val.throw === 'function'\n    && typeof val.return === 'function'\n    && typeof val.next === 'function';\n}\n\nfunction isArguments(val) {\n  try {\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\n      return true;\n    }\n  } catch (err) {\n    if (err.message.indexOf('callee') !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\n\nfunction isBuffer(val) {\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\n    return val.constructor.isBuffer(val);\n  }\n  return false;\n}\n","/**\n * A private string to identify structs by.\n *\n * @type {String}\n */\n\nconst IS_STRUCT = '@@__STRUCT__@@'\n\n/**\n * A private string to refer to a struct's kind.\n *\n * @type {String}\n */\n\nconst KIND = '@@__KIND__@@'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport { IS_STRUCT, KIND }\n","import { IS_STRUCT } from './constants'\n\n/**\n * Check if a `value` is a struct.\n *\n * @param {Any} value\n * @return {Boolean}\n */\n\nexport function isStruct(value) {\n  return !!(value && value[IS_STRUCT])\n}\n\n/**\n * Resolve `defaults`, for an optional `value`.\n *\n * @param {Function|Any} defaults\n * @param {Any} value\n * @return {Any}\n */\n\nexport function resolveDefaults(defaults, value) {\n  return typeof defaults === 'function' ? defaults(value) : defaults\n}\n","import kindOf from 'kind-of'\n\nimport { KIND } from './constants'\nimport { isStruct, resolveDefaults } from './utils'\n\n/**\n * Kind.\n *\n * @type {Kind}\n */\n\nclass Kind {\n  constructor(name, type, validate) {\n    this.name = name\n    this.type = type\n    this.validate = validate\n  }\n}\n\n/**\n * Any.\n *\n * @param {Array|Function|Object|String} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction any(schema, defaults, options) {\n  if (isStruct(schema)) {\n    return schema[KIND]\n  }\n\n  if (schema instanceof Kind) {\n    return schema\n  }\n\n  switch (kindOf(schema)) {\n    case 'array': {\n      return schema.length > 1\n        ? tuple(schema, defaults, options)\n        : list(schema, defaults, options)\n    }\n\n    case 'function': {\n      return func(schema, defaults, options)\n    }\n\n    case 'object': {\n      return object(schema, defaults, options)\n    }\n\n    case 'string': {\n      let required = true\n      let type\n\n      if (schema.endsWith('?')) {\n        required = false\n        schema = schema.slice(0, -1)\n      }\n\n      if (schema.includes('|')) {\n        const scalars = schema.split(/\\s*\\|\\s*/g)\n        type = union(scalars, defaults, options)\n      } else if (schema.includes('&')) {\n        const scalars = schema.split(/\\s*&\\s*/g)\n        type = intersection(scalars, defaults, options)\n      } else {\n        type = scalar(schema, defaults, options)\n      }\n\n      if (!required) {\n        type = optional(type, undefined, options)\n      }\n\n      return type\n    }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    throw new Error(\n      `A schema definition must be an object, array, string or function, but you passed: ${schema}`\n    )\n  } else {\n    throw new Error(`Invalid schema: ${schema}`)\n  }\n}\n\n/**\n * Dict.\n *\n * @param {Array} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction dict(schema, defaults, options) {\n  if (kindOf(schema) !== 'array' || schema.length !== 2) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Dict structs must be defined as an array with two elements, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const obj = scalar('object', undefined, options)\n  const keys = any(schema[0], undefined, options)\n  const values = any(schema[1], undefined, options)\n  const name = 'dict'\n  const type = `dict<${keys.type},${values.type}>`\n  const validate = value => {\n    const resolved = resolveDefaults(defaults)\n    value = resolved ? { ...resolved, ...value } : value\n    const [error] = obj.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    const ret = {}\n    const errors = []\n\n    for (let k in value) {\n      const v = value[k]\n      const [e, r] = keys.validate(k)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [k].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      k = r\n      const [e2, r2] = values.validate(v)\n\n      if (e2) {\n        const allE2 = e2.errors || [e2]\n        allE2.forEach(singleE => {\n          singleE.path = [k].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      ret[k] = r2\n    }\n\n    if (errors.length) {\n      const first = errors[0]\n      first.errors = errors\n      return [first]\n    }\n\n    return [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Enum.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction en(schema, defaults, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Enum structs must be defined as an array, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const name = 'enum'\n  const type = schema\n    .map(s => {\n      try {\n        return JSON.stringify(s)\n      } catch (e) {\n        return String(s)\n      }\n    })\n    .join(' | ')\n\n  const validate = (value = resolveDefaults(defaults)) => {\n    return schema.includes(value)\n      ? [undefined, value]\n      : [{ data: value, path: [], value, type }]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Enums.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction enums(schema, defaults, options) {\n  const e = en(schema, undefined, options)\n  const l = list([e], defaults, options)\n  return l\n}\n\n/**\n * Function.\n *\n * @param {Function} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction func(schema, defaults, options) {\n  if (kindOf(schema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Function structs must be defined as a function, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const name = 'function'\n  const type = '<function>'\n  const validate = (value = resolveDefaults(defaults), data) => {\n    const result = schema(value, data)\n    let failure = { path: [], reason: null }\n    let isValid\n\n    switch (kindOf(result)) {\n      case 'boolean': {\n        isValid = result\n        break\n      }\n      case 'string': {\n        isValid = false\n        failure.reason = result\n        break\n      }\n      case 'object': {\n        isValid = false\n        failure = { ...failure, ...result }\n        break\n      }\n      default: {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error(\n            `Validator functions must return a boolean, an error reason string or an error reason object, but you passed: ${schema}`\n          )\n        } else {\n          throw new Error(`Invalid result: ${result}`)\n        }\n      }\n    }\n\n    return isValid\n      ? [undefined, value]\n      : [{ type, value, data: value, ...failure }]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Instance.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction instance(schema, defaults, options) {\n  const name = 'instance'\n  const type = `instance<${schema.name}>`\n  const validate = (value = resolveDefaults(defaults)) => {\n    return value instanceof schema\n      ? [undefined, value]\n      : [{ data: value, path: [], value, type }]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Interface.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction inter(schema, defaults, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Interface structs must be defined as an object, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const ks = []\n  const properties = {}\n\n  for (const key in schema) {\n    ks.push(key)\n    const s = schema[key]\n    const kind = any(s, undefined, options)\n    properties[key] = kind\n  }\n\n  const name = 'interface'\n  const type = `{${ks.join()}}`\n  const validate = value => {\n    const resolved = resolveDefaults(defaults)\n    value = resolved ? { ...resolved, ...value } : value\n    const errors = []\n    const ret = value\n\n    for (const key in properties) {\n      let v = value[key]\n      const kind = properties[key]\n\n      if (v === undefined) {\n        const d = defaults && defaults[key]\n        v = resolveDefaults(d, value)\n      }\n\n      const [e, r] = kind.validate(v, value)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [key].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r\n      }\n    }\n\n    if (errors.length) {\n      const first = errors[0]\n      first.errors = errors\n      return [first]\n    }\n\n    return [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Lazy.\n *\n * @param {Function} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction lazy(schema, defaults, options) {\n  if (kindOf(schema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Lazy structs must be defined as an function that returns a schema, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  let kind\n  let struct\n  const name = 'lazy'\n  const type = `lazy...`\n  const compile = value => {\n    struct = schema()\n    kind.name = struct.kind\n    kind.type = struct.type\n    kind.validate = struct.validate\n    return kind.validate(value)\n  }\n\n  kind = new Kind(name, type, compile)\n  return kind\n}\n\n/**\n * Dynamic.\n *\n * @param {Function} createSchema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction dynamic(createSchema, defaults, options) {\n  if (kindOf(createSchema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Dynamic structs must be defined as a function, but you passed: ${createSchema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${createSchema}`)\n    }\n  }\n\n  const name = 'dynamic'\n  const type = 'dynamic...'\n  const validate = (value = resolveDefaults(defaults), data) => {\n    const schema = createSchema(value, data)\n\n    if (kindOf(schema) !== 'function') {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new Error(\n          `Dynamic structs must return a schema, but you passed: ${schema}`\n        )\n      } else {\n        throw new Error(`Invalid schema: ${schema}`)\n      }\n    }\n\n    const [error, result] = schema.validate(value)\n\n    if (error) {\n      return [error]\n    }\n\n    return [undefined, result]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * List.\n *\n * @param {Array} schema\n * @param {Array} defaults\n * @param {Object} options\n */\n\nfunction list(schema, defaults, options) {\n  if (kindOf(schema) !== 'array' || schema.length !== 1) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `List structs must be defined as an array with a single element, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const array = scalar('array', undefined, options)\n  const element = any(schema[0], undefined, options)\n  const name = 'list'\n  const type = `[${element.type}]`\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error, result] = array.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    value = result\n    const errors = []\n    const ret = []\n\n    for (let i = 0; i < value.length; i++) {\n      const v = value[i]\n      const [e, r] = element.validate(v)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [i].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      ret[i] = r\n    }\n\n    if (errors.length) {\n      const first = errors[0]\n      first.errors = errors\n      return [first]\n    }\n\n    return [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Literal.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction literal(schema, defaults, options) {\n  const name = 'literal'\n  const type = `literal: ${JSON.stringify(schema)}`\n  const validate = (value = resolveDefaults(defaults)) => {\n    return value === schema\n      ? [undefined, value]\n      : [{ data: value, path: [], value, type }]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Object.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction object(schema, defaults, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Object structs must be defined as an object, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const obj = scalar('object', undefined, options)\n  const ks = []\n  const properties = {}\n\n  for (const key in schema) {\n    ks.push(key)\n    const s = schema[key]\n    const kind = any(s, undefined, options)\n    properties[key] = kind\n  }\n\n  const name = 'object'\n  const type = `{${ks.join()}}`\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error] = obj.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    const errors = []\n    const ret = {}\n    const valueKeys = Object.keys(value)\n    const propertiesKeys = Object.keys(properties)\n    const keys = new Set(valueKeys.concat(propertiesKeys))\n\n    keys.forEach(key => {\n      let v = value[key]\n      const kind = properties[key]\n\n      if (v === undefined) {\n        const d = defaults && defaults[key]\n        v = resolveDefaults(d, value)\n      }\n\n      if (!kind) {\n        const e = { data: value, path: [key], value: v }\n        errors.push(e)\n        return\n      }\n\n      const [e, r] = kind.validate(v, value)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [key].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        return\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r\n      }\n    })\n\n    if (errors.length) {\n      const first = errors[0]\n      first.errors = errors\n      return [first]\n    }\n\n    return [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Optional.\n *\n * @param {Any} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction optional(schema, defaults, options) {\n  return union([schema, 'undefined'], defaults, options)\n}\n\n/**\n * Partial.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction partial(schema, defaults, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Partial structs must be defined as an object, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const obj = scalar('object', undefined, options)\n  const ks = []\n  const properties = {}\n\n  for (const key in schema) {\n    ks.push(key)\n    const s = schema[key]\n    const kind = any(s, undefined, options)\n    properties[key] = kind\n  }\n\n  const name = 'partial'\n  const type = `{${ks.join()},...}`\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error] = obj.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    const errors = []\n    const ret = {}\n\n    for (const key in properties) {\n      let v = value[key]\n      const kind = properties[key]\n\n      if (v === undefined) {\n        const d = defaults && defaults[key]\n        v = resolveDefaults(d, value)\n      }\n\n      const [e, r] = kind.validate(v, value)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [key].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r\n      }\n    }\n\n    if (errors.length) {\n      const first = errors[0]\n      first.errors = errors\n      return [first]\n    }\n\n    return [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Scalar.\n *\n * @param {String} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction scalar(schema, defaults, options) {\n  if (kindOf(schema) !== 'string') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Scalar structs must be defined as a string, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const { types } = options\n  const fn = types[schema]\n\n  if (kindOf(fn) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `No struct validator function found for type \"${schema}\".`\n      )\n    } else {\n      throw new Error(`Invalid type: ${schema}`)\n    }\n  }\n\n  const kind = func(fn, defaults, options)\n  const name = 'scalar'\n  const type = schema\n  const validate = value => {\n    const [error, result] = kind.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    return [undefined, result]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Tuple.\n *\n * @param {Array} schema\n * @param {Array} defaults\n * @param {Object} options\n */\n\nfunction tuple(schema, defaults, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Tuple structs must be defined as an array, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const kinds = schema.map(s => any(s, undefined, options))\n  const array = scalar('array', undefined, options)\n  const name = 'tuple'\n  const type = `[${kinds.map(k => k.type).join()}]`\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error] = array.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    const ret = []\n    const errors = []\n    const length = Math.max(value.length, kinds.length)\n\n    for (let i = 0; i < length; i++) {\n      const kind = kinds[i]\n      const v = value[i]\n\n      if (!kind) {\n        const e = { data: value, path: [i], value: v }\n        errors.push(e)\n        continue\n      }\n\n      const [e, r] = kind.validate(v)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [i].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      ret[i] = r\n    }\n\n    if (errors.length) {\n      const first = errors[0]\n      first.errors = errors\n      return [first]\n    }\n\n    return [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Union.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction union(schema, defaults, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Union structs must be defined as an array, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const kinds = schema.map(s => any(s, undefined, options))\n  const name = 'union'\n  const type = kinds.map(k => k.type).join(' | ')\n  const validate = (value = resolveDefaults(defaults)) => {\n    const errors = []\n\n    for (const k of kinds) {\n      const [e, r] = k.validate(value)\n\n      if (!e) {\n        return [undefined, r]\n      }\n\n      errors.push(e)\n    }\n    errors[0].type = type\n    return errors\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Intersection.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction intersection(schema, defaults, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Intersection structs must be defined as an array, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const types = schema.map(s => any(s, undefined, options))\n  const name = 'intersection'\n  const type = types.map(t => t.type).join(' & ')\n  const validate = (value = resolveDefaults(defaults)) => {\n    let v = value\n\n    for (const t of types) {\n      const [e, r] = t.validate(v)\n\n      if (e) {\n        e.type = type\n        return [e]\n      }\n\n      v = r\n    }\n\n    return [undefined, v]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Kinds.\n *\n * @type {Object}\n */\n\nconst Kinds = {\n  any,\n  dict,\n  enum: en,\n  enums,\n  function: func,\n  instance,\n  interface: inter,\n  lazy,\n  list,\n  literal,\n  object,\n  optional,\n  partial,\n  scalar,\n  tuple,\n  union,\n  intersection,\n  dynamic,\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Kinds\n","import kindOf from 'kind-of'\n\n/**\n * The types that `kind-of` supports.\n *\n * @type {Array}\n */\n\nconst TYPES = [\n  'arguments',\n  'array',\n  'boolean',\n  'buffer',\n  'error',\n  'float32array',\n  'float64array',\n  'function',\n  'generatorfunction',\n  'int16array',\n  'int32array',\n  'int8array',\n  'map',\n  'null',\n  'number',\n  'object',\n  'promise',\n  'regexp',\n  'set',\n  'string',\n  'symbol',\n  'uint16array',\n  'uint32array',\n  'uint8array',\n  'uint8clampedarray',\n  'undefined',\n  'weakmap',\n  'weakset',\n]\n\n/**\n * The default types that Superstruct ships with.\n *\n * @type {Object}\n */\n\nconst Types = {\n  any: value => value !== undefined,\n}\n\nTYPES.forEach(type => {\n  Types[type] = value => kindOf(value) === type\n})\n\n/**\n * Handle the 'date' case specially, to throw out invalid `Date` objects.\n *\n * @param {Mixed} value\n * @return {Boolean}\n */\n\nTypes.date = value => kindOf(value) === 'date' && !isNaN(value)\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Types\n","import Kinds from './kinds'\nimport StructError from './error'\nimport Types from './types'\nimport { isStruct } from './utils'\nimport { IS_STRUCT, KIND } from './constants'\n\n/**\n * Create a struct factory with a `config`.\n *\n * @param {Object} config\n * @return {Function}\n */\n\nfunction superstruct(config = {}) {\n  const types = {\n    ...Types,\n    ...(config.types || {}),\n  }\n\n  /**\n   * Create a `kind` struct with `schema`, `defaults` and `options`.\n   *\n   * @param {Any} schema\n   * @param {Any} defaults\n   * @param {Object} options\n   * @return {Function}\n   */\n\n  function struct(schema, defaults, options = {}) {\n    if (isStruct(schema)) {\n      schema = schema.schema\n    }\n\n    const kind = Kinds.any(schema, defaults, { ...options, types })\n\n    function Struct(data) {\n      if (this instanceof Struct) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error(\n            'The `Struct` creation function should not be used with the `new` keyword.'\n          )\n        } else {\n          throw new Error('Invalid `new` keyword!')\n        }\n      }\n\n      return Struct.assert(data)\n    }\n\n    Object.defineProperty(Struct, IS_STRUCT, { value: true })\n    Object.defineProperty(Struct, KIND, { value: kind })\n\n    Struct.kind = kind.name\n    Struct.type = kind.type\n    Struct.schema = schema\n    Struct.defaults = defaults\n    Struct.options = options\n\n    Struct.assert = value => {\n      const [error, result] = kind.validate(value)\n\n      if (error) {\n        throw new StructError(error)\n      }\n\n      return result\n    }\n\n    Struct.test = value => {\n      const [error] = kind.validate(value)\n      return !error\n    }\n\n    Struct.validate = value => {\n      const [error, result] = kind.validate(value)\n\n      if (error) {\n        return [new StructError(error)]\n      }\n\n      return [undefined, result]\n    }\n\n    return Struct\n  }\n\n  /**\n   * Mix in a factory for each specific kind of struct.\n   */\n\n  Object.keys(Kinds).forEach(name => {\n    const kind = Kinds[name]\n\n    struct[name] = (schema, defaults, options) => {\n      const type = kind(schema, defaults, { ...options, types })\n      const s = struct(type, defaults, options)\n      return s\n    }\n  })\n\n  /**\n   * Return the struct factory.\n   */\n\n  return struct\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default superstruct\n","import StructError from './error'\nimport superstruct from './superstruct'\nimport { isStruct } from './utils'\n\n/**\n * Create a convenience `struct` factory for the default types.\n *\n * @type {Function}\n */\n\nconst struct = superstruct()\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport { struct, superstruct, isStruct, StructError }\n"],"sourceRoot":""}