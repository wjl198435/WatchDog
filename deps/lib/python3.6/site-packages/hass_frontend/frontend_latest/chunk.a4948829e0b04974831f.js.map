{"version":3,"sources":["webpack:///../src/error.js","webpack:///../node_modules/kind-of/index.js","webpack:///../src/constants.js","webpack:///../src/utils.js","webpack:///../src/kinds.js","webpack:///../src/types.js","webpack:///../src/superstruct.js","webpack:///../src/index.js","webpack:///./node_modules/@polymer/iron-autogrow-textarea/iron-autogrow-textarea.js","webpack:///./node_modules/@polymer/paper-input/paper-textarea.js"],"names":["__webpack_require__","d","__webpack_exports__","superstruct","StructError","TypeError","attrs","type","path","value","JSON","data","reason","errors","length","push","this","Error","captureStackTrace","constructor","stack","toString","Object","prototype","kindOf","val","ctorName","Array","isArray","isBuffer","callee","err","message","indexOf","isArguments","Date","toDateString","getDate","setDate","isDate","stackTraceLimit","isError","RegExp","flags","ignoreCase","multiline","global","isRegexp","throw","return","next","isGeneratorObj","call","slice","toLowerCase","replace","name","IS_STRUCT","KIND","isStruct","resolveDefaults","defaults","Kind","validate","any","schema","defaults$$1","options","tuple","list","func","object","required","union","intersection","scalar","optional","en","map","s","e","String","join","undefined","result","isValid","failure","_extends","array","element","error","ret","i","v","r","forEach","singleE","concat","first","obj","ks","properties","key","kind","valueKeys","propertiesKeys","Set","types","fn","kinds","k","Math","t","Kinds","dict","keys","values","resolved","e2","r2","enums","instance","lazy","struct","literal","partial","createSchema","Types","config","Struct","defineProperty","assert","test","TYPES","isNaN","Polymer","_template","html","is","behaviors","IronValidatableBehavior","IronControlState","observer","notify","bindValue","rows","Number","maxRows","autocomplete","autofocus","Boolean","inputmode","placeholder","readonly","minlength","maxlength","label","listeners","input","textarea","$","selectionStart","selectionEnd","attached","navigator","userAgent","match","style","marginLeft","valid","validity","hasValidator","invalid","fire","_bindValueChanged","_valueChanged","mirror","innerHTML","_valueForMirror","_onInput","event","eventPath","dom","target","_constrain","tokens","_tokens","split","_updateCached","PaperInputBehavior","IronFormElementBehavior","_ariaLabelledBy","_ariaDescribedBy","start","end","_ariaLabelledByChanged","ariaLabelledBy","_focusableElement","setAttribute","_ariaDescribedByChanged","ariaDescribedBy","inputElement"],"mappings":"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","file":"chunk.a4948829e0b04974831f.js","sourcesContent":["/**\n * Define a struct error.\n *\n * @type {StructError}\n */\n\nclass StructError extends TypeError {\n  static format(attrs) {\n    const { type, path, value } = attrs\n    const message = `Expected a value of type \\`${type}\\`${\n      path.length ? ` for \\`${path.join('.')}\\`` : ''\n    } but received \\`${JSON.stringify(value)}\\`.`\n    return message\n  }\n\n  constructor(attrs) {\n    const message = StructError.format(attrs)\n    super(message)\n\n    const { data, path, value, reason, type, errors = [] } = attrs\n    this.data = data\n    this.path = path\n    this.value = value\n    this.reason = reason\n    this.type = type\n    this.errors = errors\n\n    if (!errors.length) {\n      errors.push(this)\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor)\n    } else {\n      this.stack = new Error().stack\n    }\n  }\n}\n\n/**\n * Export.\n *\n * @type {StructError}\n */\n\nexport default StructError\n","var toString = Object.prototype.toString;\n\nmodule.exports = function kindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n\n  var type = typeof val;\n  if (type === 'boolean') return 'boolean';\n  if (type === 'string') return 'string';\n  if (type === 'number') return 'number';\n  if (type === 'symbol') return 'symbol';\n  if (type === 'function') {\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\n  }\n\n  if (isArray(val)) return 'array';\n  if (isBuffer(val)) return 'buffer';\n  if (isArguments(val)) return 'arguments';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  if (isRegexp(val)) return 'regexp';\n\n  switch (ctorName(val)) {\n    case 'Symbol': return 'symbol';\n    case 'Promise': return 'promise';\n\n    // Set, Map, WeakSet, WeakMap\n    case 'WeakMap': return 'weakmap';\n    case 'WeakSet': return 'weakset';\n    case 'Map': return 'map';\n    case 'Set': return 'set';\n\n    // 8-bit typed arrays\n    case 'Int8Array': return 'int8array';\n    case 'Uint8Array': return 'uint8array';\n    case 'Uint8ClampedArray': return 'uint8clampedarray';\n\n    // 16-bit typed arrays\n    case 'Int16Array': return 'int16array';\n    case 'Uint16Array': return 'uint16array';\n\n    // 32-bit typed arrays\n    case 'Int32Array': return 'int32array';\n    case 'Uint32Array': return 'uint32array';\n    case 'Float32Array': return 'float32array';\n    case 'Float64Array': return 'float64array';\n  }\n\n  if (isGeneratorObj(val)) {\n    return 'generator';\n  }\n\n  // Non-plain objects\n  type = toString.call(val);\n  switch (type) {\n    case '[object Object]': return 'object';\n    // iterators\n    case '[object Map Iterator]': return 'mapiterator';\n    case '[object Set Iterator]': return 'setiterator';\n    case '[object String Iterator]': return 'stringiterator';\n    case '[object Array Iterator]': return 'arrayiterator';\n  }\n\n  // other\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n};\n\nfunction ctorName(val) {\n  return val.constructor ? val.constructor.name : null;\n}\n\nfunction isArray(val) {\n  if (Array.isArray) return Array.isArray(val);\n  return val instanceof Array;\n}\n\nfunction isError(val) {\n  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function'\n    && typeof val.getDate === 'function'\n    && typeof val.setDate === 'function';\n}\n\nfunction isRegexp(val) {\n  if (val instanceof RegExp) return true;\n  return typeof val.flags === 'string'\n    && typeof val.ignoreCase === 'boolean'\n    && typeof val.multiline === 'boolean'\n    && typeof val.global === 'boolean';\n}\n\nfunction isGeneratorFn(name, val) {\n  return ctorName(name) === 'GeneratorFunction';\n}\n\nfunction isGeneratorObj(val) {\n  return typeof val.throw === 'function'\n    && typeof val.return === 'function'\n    && typeof val.next === 'function';\n}\n\nfunction isArguments(val) {\n  try {\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\n      return true;\n    }\n  } catch (err) {\n    if (err.message.indexOf('callee') !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\n\nfunction isBuffer(val) {\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\n    return val.constructor.isBuffer(val);\n  }\n  return false;\n}\n","/**\n * A private string to identify structs by.\n *\n * @type {String}\n */\n\nconst IS_STRUCT = '@@__STRUCT__@@'\n\n/**\n * A private string to refer to a struct's kind.\n *\n * @type {String}\n */\n\nconst KIND = '@@__KIND__@@'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport { IS_STRUCT, KIND }\n","import { IS_STRUCT } from './constants'\n\n/**\n * Check if a `value` is a struct.\n *\n * @param {Any} value\n * @return {Boolean}\n */\n\nexport function isStruct(value) {\n  return !!(value && value[IS_STRUCT])\n}\n\n/**\n * Resolve `defaults`, for an optional `value`.\n *\n * @param {Function|Any} defaults\n * @param {Any} value\n * @return {Any}\n */\n\nexport function resolveDefaults(defaults, value) {\n  return typeof defaults === 'function' ? defaults(value) : defaults\n}\n","import kindOf from 'kind-of'\n\nimport { KIND } from './constants'\nimport { isStruct, resolveDefaults } from './utils'\n\n/**\n * Kind.\n *\n * @type {Kind}\n */\n\nclass Kind {\n  constructor(name, type, validate) {\n    this.name = name\n    this.type = type\n    this.validate = validate\n  }\n}\n\n/**\n * Any.\n *\n * @param {Array|Function|Object|String} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction any(schema, defaults, options) {\n  if (isStruct(schema)) {\n    return schema[KIND]\n  }\n\n  if (schema instanceof Kind) {\n    return schema\n  }\n\n  switch (kindOf(schema)) {\n    case 'array': {\n      return schema.length > 1\n        ? tuple(schema, defaults, options)\n        : list(schema, defaults, options)\n    }\n\n    case 'function': {\n      return func(schema, defaults, options)\n    }\n\n    case 'object': {\n      return object(schema, defaults, options)\n    }\n\n    case 'string': {\n      let required = true\n      let type\n\n      if (schema.endsWith('?')) {\n        required = false\n        schema = schema.slice(0, -1)\n      }\n\n      if (schema.includes('|')) {\n        const scalars = schema.split(/\\s*\\|\\s*/g)\n        type = union(scalars, defaults, options)\n      } else if (schema.includes('&')) {\n        const scalars = schema.split(/\\s*&\\s*/g)\n        type = intersection(scalars, defaults, options)\n      } else {\n        type = scalar(schema, defaults, options)\n      }\n\n      if (!required) {\n        type = optional(type, undefined, options)\n      }\n\n      return type\n    }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    throw new Error(\n      `A schema definition must be an object, array, string or function, but you passed: ${schema}`\n    )\n  } else {\n    throw new Error(`Invalid schema: ${schema}`)\n  }\n}\n\n/**\n * Dict.\n *\n * @param {Array} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction dict(schema, defaults, options) {\n  if (kindOf(schema) !== 'array' || schema.length !== 2) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Dict structs must be defined as an array with two elements, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const obj = scalar('object', undefined, options)\n  const keys = any(schema[0], undefined, options)\n  const values = any(schema[1], undefined, options)\n  const name = 'dict'\n  const type = `dict<${keys.type},${values.type}>`\n  const validate = value => {\n    const resolved = resolveDefaults(defaults)\n    value = resolved ? { ...resolved, ...value } : value\n    const [error] = obj.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    const ret = {}\n    const errors = []\n\n    for (let k in value) {\n      const v = value[k]\n      const [e, r] = keys.validate(k)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [k].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      k = r\n      const [e2, r2] = values.validate(v)\n\n      if (e2) {\n        const allE2 = e2.errors || [e2]\n        allE2.forEach(singleE => {\n          singleE.path = [k].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      ret[k] = r2\n    }\n\n    if (errors.length) {\n      const first = errors[0]\n      first.errors = errors\n      return [first]\n    }\n\n    return [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Enum.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction en(schema, defaults, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Enum structs must be defined as an array, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const name = 'enum'\n  const type = schema\n    .map(s => {\n      try {\n        return JSON.stringify(s)\n      } catch (e) {\n        return String(s)\n      }\n    })\n    .join(' | ')\n\n  const validate = (value = resolveDefaults(defaults)) => {\n    return schema.includes(value)\n      ? [undefined, value]\n      : [{ data: value, path: [], value, type }]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Enums.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction enums(schema, defaults, options) {\n  const e = en(schema, undefined, options)\n  const l = list([e], defaults, options)\n  return l\n}\n\n/**\n * Function.\n *\n * @param {Function} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction func(schema, defaults, options) {\n  if (kindOf(schema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Function structs must be defined as a function, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const name = 'function'\n  const type = '<function>'\n  const validate = (value = resolveDefaults(defaults), data) => {\n    const result = schema(value, data)\n    let failure = { path: [], reason: null }\n    let isValid\n\n    switch (kindOf(result)) {\n      case 'boolean': {\n        isValid = result\n        break\n      }\n      case 'string': {\n        isValid = false\n        failure.reason = result\n        break\n      }\n      case 'object': {\n        isValid = false\n        failure = { ...failure, ...result }\n        break\n      }\n      default: {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error(\n            `Validator functions must return a boolean, an error reason string or an error reason object, but you passed: ${schema}`\n          )\n        } else {\n          throw new Error(`Invalid result: ${result}`)\n        }\n      }\n    }\n\n    return isValid\n      ? [undefined, value]\n      : [{ type, value, data: value, ...failure }]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Instance.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction instance(schema, defaults, options) {\n  const name = 'instance'\n  const type = `instance<${schema.name}>`\n  const validate = (value = resolveDefaults(defaults)) => {\n    return value instanceof schema\n      ? [undefined, value]\n      : [{ data: value, path: [], value, type }]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Interface.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction inter(schema, defaults, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Interface structs must be defined as an object, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const ks = []\n  const properties = {}\n\n  for (const key in schema) {\n    ks.push(key)\n    const s = schema[key]\n    const kind = any(s, undefined, options)\n    properties[key] = kind\n  }\n\n  const name = 'interface'\n  const type = `{${ks.join()}}`\n  const validate = value => {\n    const resolved = resolveDefaults(defaults)\n    value = resolved ? { ...resolved, ...value } : value\n    const errors = []\n    const ret = value\n\n    for (const key in properties) {\n      let v = value[key]\n      const kind = properties[key]\n\n      if (v === undefined) {\n        const d = defaults && defaults[key]\n        v = resolveDefaults(d, value)\n      }\n\n      const [e, r] = kind.validate(v, value)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [key].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r\n      }\n    }\n\n    if (errors.length) {\n      const first = errors[0]\n      first.errors = errors\n      return [first]\n    }\n\n    return [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Lazy.\n *\n * @param {Function} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction lazy(schema, defaults, options) {\n  if (kindOf(schema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Lazy structs must be defined as an function that returns a schema, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  let kind\n  let struct\n  const name = 'lazy'\n  const type = `lazy...`\n  const compile = value => {\n    struct = schema()\n    kind.name = struct.kind\n    kind.type = struct.type\n    kind.validate = struct.validate\n    return kind.validate(value)\n  }\n\n  kind = new Kind(name, type, compile)\n  return kind\n}\n\n/**\n * Dynamic.\n *\n * @param {Function} createSchema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction dynamic(createSchema, defaults, options) {\n  if (kindOf(createSchema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Dynamic structs must be defined as a function, but you passed: ${createSchema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${createSchema}`)\n    }\n  }\n\n  const name = 'dynamic'\n  const type = 'dynamic...'\n  const validate = (value = resolveDefaults(defaults), data) => {\n    const schema = createSchema(value, data)\n\n    if (kindOf(schema) !== 'function') {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new Error(\n          `Dynamic structs must return a schema, but you passed: ${schema}`\n        )\n      } else {\n        throw new Error(`Invalid schema: ${schema}`)\n      }\n    }\n\n    const [error, result] = schema.validate(value)\n\n    if (error) {\n      return [error]\n    }\n\n    return [undefined, result]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * List.\n *\n * @param {Array} schema\n * @param {Array} defaults\n * @param {Object} options\n */\n\nfunction list(schema, defaults, options) {\n  if (kindOf(schema) !== 'array' || schema.length !== 1) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `List structs must be defined as an array with a single element, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const array = scalar('array', undefined, options)\n  const element = any(schema[0], undefined, options)\n  const name = 'list'\n  const type = `[${element.type}]`\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error, result] = array.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    value = result\n    const errors = []\n    const ret = []\n\n    for (let i = 0; i < value.length; i++) {\n      const v = value[i]\n      const [e, r] = element.validate(v)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [i].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      ret[i] = r\n    }\n\n    if (errors.length) {\n      const first = errors[0]\n      first.errors = errors\n      return [first]\n    }\n\n    return [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Literal.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction literal(schema, defaults, options) {\n  const name = 'literal'\n  const type = `literal: ${JSON.stringify(schema)}`\n  const validate = (value = resolveDefaults(defaults)) => {\n    return value === schema\n      ? [undefined, value]\n      : [{ data: value, path: [], value, type }]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Object.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction object(schema, defaults, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Object structs must be defined as an object, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const obj = scalar('object', undefined, options)\n  const ks = []\n  const properties = {}\n\n  for (const key in schema) {\n    ks.push(key)\n    const s = schema[key]\n    const kind = any(s, undefined, options)\n    properties[key] = kind\n  }\n\n  const name = 'object'\n  const type = `{${ks.join()}}`\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error] = obj.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    const errors = []\n    const ret = {}\n    const valueKeys = Object.keys(value)\n    const propertiesKeys = Object.keys(properties)\n    const keys = new Set(valueKeys.concat(propertiesKeys))\n\n    keys.forEach(key => {\n      let v = value[key]\n      const kind = properties[key]\n\n      if (v === undefined) {\n        const d = defaults && defaults[key]\n        v = resolveDefaults(d, value)\n      }\n\n      if (!kind) {\n        const e = { data: value, path: [key], value: v }\n        errors.push(e)\n        return\n      }\n\n      const [e, r] = kind.validate(v, value)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [key].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        return\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r\n      }\n    })\n\n    if (errors.length) {\n      const first = errors[0]\n      first.errors = errors\n      return [first]\n    }\n\n    return [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Optional.\n *\n * @param {Any} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction optional(schema, defaults, options) {\n  return union([schema, 'undefined'], defaults, options)\n}\n\n/**\n * Partial.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction partial(schema, defaults, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Partial structs must be defined as an object, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const obj = scalar('object', undefined, options)\n  const ks = []\n  const properties = {}\n\n  for (const key in schema) {\n    ks.push(key)\n    const s = schema[key]\n    const kind = any(s, undefined, options)\n    properties[key] = kind\n  }\n\n  const name = 'partial'\n  const type = `{${ks.join()},...}`\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error] = obj.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    const errors = []\n    const ret = {}\n\n    for (const key in properties) {\n      let v = value[key]\n      const kind = properties[key]\n\n      if (v === undefined) {\n        const d = defaults && defaults[key]\n        v = resolveDefaults(d, value)\n      }\n\n      const [e, r] = kind.validate(v, value)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [key].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r\n      }\n    }\n\n    if (errors.length) {\n      const first = errors[0]\n      first.errors = errors\n      return [first]\n    }\n\n    return [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Scalar.\n *\n * @param {String} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction scalar(schema, defaults, options) {\n  if (kindOf(schema) !== 'string') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Scalar structs must be defined as a string, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const { types } = options\n  const fn = types[schema]\n\n  if (kindOf(fn) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `No struct validator function found for type \"${schema}\".`\n      )\n    } else {\n      throw new Error(`Invalid type: ${schema}`)\n    }\n  }\n\n  const kind = func(fn, defaults, options)\n  const name = 'scalar'\n  const type = schema\n  const validate = value => {\n    const [error, result] = kind.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    return [undefined, result]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Tuple.\n *\n * @param {Array} schema\n * @param {Array} defaults\n * @param {Object} options\n */\n\nfunction tuple(schema, defaults, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Tuple structs must be defined as an array, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const kinds = schema.map(s => any(s, undefined, options))\n  const array = scalar('array', undefined, options)\n  const name = 'tuple'\n  const type = `[${kinds.map(k => k.type).join()}]`\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error] = array.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    const ret = []\n    const errors = []\n    const length = Math.max(value.length, kinds.length)\n\n    for (let i = 0; i < length; i++) {\n      const kind = kinds[i]\n      const v = value[i]\n\n      if (!kind) {\n        const e = { data: value, path: [i], value: v }\n        errors.push(e)\n        continue\n      }\n\n      const [e, r] = kind.validate(v)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [i].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      ret[i] = r\n    }\n\n    if (errors.length) {\n      const first = errors[0]\n      first.errors = errors\n      return [first]\n    }\n\n    return [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Union.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction union(schema, defaults, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Union structs must be defined as an array, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const kinds = schema.map(s => any(s, undefined, options))\n  const name = 'union'\n  const type = kinds.map(k => k.type).join(' | ')\n  const validate = (value = resolveDefaults(defaults)) => {\n    const errors = []\n\n    for (const k of kinds) {\n      const [e, r] = k.validate(value)\n\n      if (!e) {\n        return [undefined, r]\n      }\n\n      errors.push(e)\n    }\n    errors[0].type = type\n    return errors\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Intersection.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction intersection(schema, defaults, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Intersection structs must be defined as an array, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const types = schema.map(s => any(s, undefined, options))\n  const name = 'intersection'\n  const type = types.map(t => t.type).join(' & ')\n  const validate = (value = resolveDefaults(defaults)) => {\n    let v = value\n\n    for (const t of types) {\n      const [e, r] = t.validate(v)\n\n      if (e) {\n        e.type = type\n        return [e]\n      }\n\n      v = r\n    }\n\n    return [undefined, v]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Kinds.\n *\n * @type {Object}\n */\n\nconst Kinds = {\n  any,\n  dict,\n  enum: en,\n  enums,\n  function: func,\n  instance,\n  interface: inter,\n  lazy,\n  list,\n  literal,\n  object,\n  optional,\n  partial,\n  scalar,\n  tuple,\n  union,\n  intersection,\n  dynamic,\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Kinds\n","import kindOf from 'kind-of'\n\n/**\n * The types that `kind-of` supports.\n *\n * @type {Array}\n */\n\nconst TYPES = [\n  'arguments',\n  'array',\n  'boolean',\n  'buffer',\n  'error',\n  'float32array',\n  'float64array',\n  'function',\n  'generatorfunction',\n  'int16array',\n  'int32array',\n  'int8array',\n  'map',\n  'null',\n  'number',\n  'object',\n  'promise',\n  'regexp',\n  'set',\n  'string',\n  'symbol',\n  'uint16array',\n  'uint32array',\n  'uint8array',\n  'uint8clampedarray',\n  'undefined',\n  'weakmap',\n  'weakset',\n]\n\n/**\n * The default types that Superstruct ships with.\n *\n * @type {Object}\n */\n\nconst Types = {\n  any: value => value !== undefined,\n}\n\nTYPES.forEach(type => {\n  Types[type] = value => kindOf(value) === type\n})\n\n/**\n * Handle the 'date' case specially, to throw out invalid `Date` objects.\n *\n * @param {Mixed} value\n * @return {Boolean}\n */\n\nTypes.date = value => kindOf(value) === 'date' && !isNaN(value)\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Types\n","import Kinds from './kinds'\nimport StructError from './error'\nimport Types from './types'\nimport { isStruct } from './utils'\nimport { IS_STRUCT, KIND } from './constants'\n\n/**\n * Create a struct factory with a `config`.\n *\n * @param {Object} config\n * @return {Function}\n */\n\nfunction superstruct(config = {}) {\n  const types = {\n    ...Types,\n    ...(config.types || {}),\n  }\n\n  /**\n   * Create a `kind` struct with `schema`, `defaults` and `options`.\n   *\n   * @param {Any} schema\n   * @param {Any} defaults\n   * @param {Object} options\n   * @return {Function}\n   */\n\n  function struct(schema, defaults, options = {}) {\n    if (isStruct(schema)) {\n      schema = schema.schema\n    }\n\n    const kind = Kinds.any(schema, defaults, { ...options, types })\n\n    function Struct(data) {\n      if (this instanceof Struct) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error(\n            'The `Struct` creation function should not be used with the `new` keyword.'\n          )\n        } else {\n          throw new Error('Invalid `new` keyword!')\n        }\n      }\n\n      return Struct.assert(data)\n    }\n\n    Object.defineProperty(Struct, IS_STRUCT, { value: true })\n    Object.defineProperty(Struct, KIND, { value: kind })\n\n    Struct.kind = kind.name\n    Struct.type = kind.type\n    Struct.schema = schema\n    Struct.defaults = defaults\n    Struct.options = options\n\n    Struct.assert = value => {\n      const [error, result] = kind.validate(value)\n\n      if (error) {\n        throw new StructError(error)\n      }\n\n      return result\n    }\n\n    Struct.test = value => {\n      const [error] = kind.validate(value)\n      return !error\n    }\n\n    Struct.validate = value => {\n      const [error, result] = kind.validate(value)\n\n      if (error) {\n        return [new StructError(error)]\n      }\n\n      return [undefined, result]\n    }\n\n    return Struct\n  }\n\n  /**\n   * Mix in a factory for each specific kind of struct.\n   */\n\n  Object.keys(Kinds).forEach(name => {\n    const kind = Kinds[name]\n\n    struct[name] = (schema, defaults, options) => {\n      const type = kind(schema, defaults, { ...options, types })\n      const s = struct(type, defaults, options)\n      return s\n    }\n  })\n\n  /**\n   * Return the struct factory.\n   */\n\n  return struct\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default superstruct\n","import StructError from './error'\nimport superstruct from './superstruct'\nimport { isStruct } from './utils'\n\n/**\n * Create a convenience `struct` factory for the default types.\n *\n * @type {Function}\n */\n\nconst struct = superstruct()\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport { struct, superstruct, isStruct, StructError }\n","/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\nimport '@polymer/iron-flex-layout/iron-flex-layout.js';\n\nimport {IronControlState} from '@polymer/iron-behaviors/iron-control-state.js';\nimport {IronValidatableBehavior} from '@polymer/iron-validatable-behavior/iron-validatable-behavior.js';\nimport {Polymer} from '@polymer/polymer/lib/legacy/polymer-fn.js';\nimport {dom} from '@polymer/polymer/lib/legacy/polymer.dom.js';\nimport {html} from '@polymer/polymer/lib/utils/html-tag.js';\n\n/**\n`iron-autogrow-textarea` is an element containing a textarea that grows in\nheight as more lines of input are entered. Unless an explicit height or the\n`maxRows` property is set, it will never scroll.\n\nExample:\n\n    <iron-autogrow-textarea></iron-autogrow-textarea>\n\n### Styling\n\nThe following custom properties and mixins are available for styling:\n\nCustom property | Description | Default\n----------------|-------------|----------\n`--iron-autogrow-textarea` | Mixin applied to the textarea | `{}`\n`--iron-autogrow-textarea-placeholder` | Mixin applied to the textarea placeholder | `{}`\n\n@group Iron Elements\n@hero hero.svg\n@demo demo/index.html\n*/\nPolymer({\n  _template: html`\n    <style>\n      :host {\n        display: inline-block;\n        position: relative;\n        width: 400px;\n        border: 1px solid;\n        padding: 2px;\n        -moz-appearance: textarea;\n        -webkit-appearance: textarea;\n        overflow: hidden;\n      }\n\n      .mirror-text {\n        visibility: hidden;\n        word-wrap: break-word;\n        @apply --iron-autogrow-textarea;\n      }\n\n      .fit {\n        @apply --layout-fit;\n      }\n\n      textarea {\n        position: relative;\n        outline: none;\n        border: none;\n        resize: none;\n        background: inherit;\n        color: inherit;\n        /* see comments in template */\n        width: 100%;\n        height: 100%;\n        font-size: inherit;\n        font-family: inherit;\n        line-height: inherit;\n        text-align: inherit;\n        @apply --iron-autogrow-textarea;\n      }\n\n      textarea::-webkit-input-placeholder {\n        @apply --iron-autogrow-textarea-placeholder;\n      }\n\n      textarea:-moz-placeholder {\n        @apply --iron-autogrow-textarea-placeholder;\n      }\n\n      textarea::-moz-placeholder {\n        @apply --iron-autogrow-textarea-placeholder;\n      }\n\n      textarea:-ms-input-placeholder {\n        @apply --iron-autogrow-textarea-placeholder;\n      }\n    </style>\n\n    <!-- the mirror sizes the input/textarea so it grows with typing -->\n    <!-- use &#160; instead &nbsp; of to allow this element to be used in XHTML -->\n    <div id=\"mirror\" class=\"mirror-text\" aria-hidden=\"true\">&nbsp;</div>\n\n    <!-- size the input/textarea with a div, because the textarea has intrinsic size in ff -->\n    <div class=\"textarea-container fit\">\n      <textarea id=\"textarea\" name\\$=\"[[name]]\" aria-label\\$=\"[[label]]\" autocomplete\\$=\"[[autocomplete]]\" autofocus\\$=\"[[autofocus]]\" inputmode\\$=\"[[inputmode]]\" placeholder\\$=\"[[placeholder]]\" readonly\\$=\"[[readonly]]\" required\\$=\"[[required]]\" disabled\\$=\"[[disabled]]\" rows\\$=\"[[rows]]\" minlength\\$=\"[[minlength]]\" maxlength\\$=\"[[maxlength]]\"></textarea>\n    </div>\n`,\n\n  is: 'iron-autogrow-textarea',\n  behaviors: [IronValidatableBehavior, IronControlState],\n\n  properties: {\n    /**\n     * Use this property instead of `bind-value` for two-way data binding.\n     * @type {string|number}\n     */\n    value: {observer: '_valueChanged', type: String, notify: true},\n\n    /**\n     * This property is deprecated, and just mirrors `value`. Use `value`\n     * instead.\n     * @type {string|number}\n     */\n    bindValue: {observer: '_bindValueChanged', type: String, notify: true},\n\n    /**\n     * The initial number of rows.\n     *\n     * @attribute rows\n     * @type number\n     * @default 1\n     */\n    rows: {type: Number, value: 1, observer: '_updateCached'},\n\n    /**\n     * The maximum number of rows this element can grow to until it\n     * scrolls. 0 means no maximum.\n     *\n     * @attribute maxRows\n     * @type number\n     * @default 0\n     */\n    maxRows: {type: Number, value: 0, observer: '_updateCached'},\n\n    /**\n     * Bound to the textarea's `autocomplete` attribute.\n     */\n    autocomplete: {type: String, value: 'off'},\n\n    /**\n     * Bound to the textarea's `autofocus` attribute.\n     */\n    autofocus: {type: Boolean, value: false},\n\n    /**\n     * Bound to the textarea's `inputmode` attribute.\n     */\n    inputmode: {type: String},\n\n    /**\n     * Bound to the textarea's `placeholder` attribute.\n     */\n    placeholder: {type: String},\n\n    /**\n     * Bound to the textarea's `readonly` attribute.\n     */\n    readonly: {type: String},\n\n    /**\n     * Set to true to mark the textarea as required.\n     */\n    required: {type: Boolean},\n\n    /**\n     * The minimum length of the input value.\n     */\n    minlength: {type: Number},\n\n    /**\n     * The maximum length of the input value.\n     */\n    maxlength: {type: Number},\n\n    /**\n     * Bound to the textarea's `aria-label` attribute.\n     */\n    label: {type: String}\n\n  },\n\n  listeners: {'input': '_onInput'},\n\n  /**\n   * Returns the underlying textarea.\n   * @return {!HTMLTextAreaElement}\n   */\n  get textarea() {\n    return this.$.textarea;\n  },\n\n  /**\n   * Returns textarea's selection start.\n   * @return {number}\n   */\n  get selectionStart() {\n    return this.$.textarea.selectionStart;\n  },\n\n  /**\n   * Returns textarea's selection end.\n   * @return {number}\n   */\n  get selectionEnd() {\n    return this.$.textarea.selectionEnd;\n  },\n\n  /**\n   * Sets the textarea's selection start.\n   */\n  set selectionStart(value) {\n    this.$.textarea.selectionStart = value;\n  },\n\n  /**\n   * Sets the textarea's selection end.\n   */\n  set selectionEnd(value) {\n    this.$.textarea.selectionEnd = value;\n  },\n\n  attached: function() {\n    /* iOS has an arbitrary left margin of 3px that isn't present\n     * in any other browser, and means that the paper-textarea's cursor\n     * overlaps the label.\n     * See https://github.com/PolymerElements/paper-input/issues/468.\n     */\n    var IS_IOS = navigator.userAgent.match(/iP(?:[oa]d|hone)/);\n    if (IS_IOS) {\n      this.$.textarea.style.marginLeft = '-3px';\n    }\n  },\n\n  /**\n   * Returns true if `value` is valid. The validator provided in `validator`\n   * will be used first, if it exists; otherwise, the `textarea`'s validity\n   * is used.\n   * @return {boolean} True if the value is valid.\n   */\n  validate: function() {\n    // Use the nested input's native validity.\n    var valid = this.$.textarea.validity.valid;\n\n    // Only do extra checking if the browser thought this was valid.\n    if (valid) {\n      // Empty, required input is invalid\n      if (this.required && this.value === '') {\n        valid = false;\n      } else if (this.hasValidator()) {\n        valid = IronValidatableBehavior.validate.call(this, this.value);\n      }\n    }\n\n    this.invalid = !valid;\n    this.fire('iron-input-validate');\n    return valid;\n  },\n\n  _bindValueChanged: function(bindValue) {\n    this.value = bindValue;\n  },\n\n  _valueChanged: function(value) {\n    var textarea = this.textarea;\n    if (!textarea) {\n      return;\n    }\n\n    // If the bindValue changed manually, then we need to also update\n    // the underlying textarea's value. Otherwise this change was probably\n    // generated from the _onInput handler, and the two values are already\n    // the same.\n    if (textarea.value !== value) {\n      textarea.value = !(value || value === 0) ? '' : value;\n    }\n\n    this.bindValue = value;\n    this.$.mirror.innerHTML = this._valueForMirror();\n\n    // Manually notify because we don't want to notify until after setting\n    // value.\n    this.fire('bind-value-changed', {value: this.bindValue});\n  },\n\n  _onInput: function(event) {\n    var eventPath = dom(event).path;\n    this.value = eventPath ? eventPath[0].value : event.target.value;\n  },\n\n  _constrain: function(tokens) {\n    var _tokens;\n    tokens = tokens || [''];\n    // Enforce the min and max heights for a multiline input to avoid\n    // measurement\n    if (this.maxRows > 0 && tokens.length > this.maxRows) {\n      _tokens = tokens.slice(0, this.maxRows);\n    } else {\n      _tokens = tokens.slice(0);\n    }\n    while (this.rows > 0 && _tokens.length < this.rows) {\n      _tokens.push('');\n    }\n    // Use &#160; instead &nbsp; of to allow this element to be used in XHTML.\n    return _tokens.join('<br/>') + '&#160;';\n  },\n\n  _valueForMirror: function() {\n    var input = this.textarea;\n    if (!input) {\n      return;\n    }\n    this.tokens = (input && input.value) ? input.value.replace(/&/gm, '&amp;')\n                                               .replace(/\"/gm, '&quot;')\n                                               .replace(/'/gm, '&#39;')\n                                               .replace(/</gm, '&lt;')\n                                               .replace(/>/gm, '&gt;')\n                                               .split('\\n') :\n                                           [''];\n    return this._constrain(this.tokens);\n  },\n\n  _updateCached: function() {\n    this.$.mirror.innerHTML = this._constrain(this.tokens);\n  }\n});\n","/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\nimport '@polymer/iron-autogrow-textarea/iron-autogrow-textarea.js';\nimport './paper-input-char-counter.js';\nimport './paper-input-container.js';\nimport './paper-input-error.js';\n\nimport {IronFormElementBehavior} from '@polymer/iron-form-element-behavior/iron-form-element-behavior.js';\nimport {Polymer} from '@polymer/polymer/lib/legacy/polymer-fn.js';\nimport {html} from '@polymer/polymer/lib/utils/html-tag.js';\n\nimport {PaperInputBehavior} from './paper-input-behavior.js';\n\n/*\n`<paper-textarea>` is a multi-line text field with Material Design styling.\n\n    <paper-textarea label=\"Textarea label\"></paper-textarea>\n\nSee `Polymer.PaperInputBehavior` for more API docs.\n\n### Validation\n\nCurrently only `required` and `maxlength` validation is supported.\n\n### Styling\n\nSee `Polymer.PaperInputContainer` for a list of custom properties used to\nstyle this element.\n*/\nPolymer({\n  _template: html`\n    <style>\n      :host {\n        display: block;\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      label {\n        pointer-events: none;\n      }\n    </style>\n\n    <paper-input-container no-label-float$=\"[[noLabelFloat]]\" always-float-label=\"[[_computeAlwaysFloatLabel(alwaysFloatLabel,placeholder)]]\" auto-validate$=\"[[autoValidate]]\" disabled$=\"[[disabled]]\" invalid=\"[[invalid]]\">\n\n      <label hidden$=\"[[!label]]\" aria-hidden=\"true\" for$=\"[[_inputId]]\" slot=\"label\">[[label]]</label>\n\n      <iron-autogrow-textarea class=\"paper-input-input\" slot=\"input\" id$=\"[[_inputId]]\" aria-labelledby$=\"[[_ariaLabelledBy]]\" aria-describedby$=\"[[_ariaDescribedBy]]\" bind-value=\"{{value}}\" invalid=\"{{invalid}}\" validator$=\"[[validator]]\" disabled$=\"[[disabled]]\" autocomplete$=\"[[autocomplete]]\" autofocus$=\"[[autofocus]]\" inputmode$=\"[[inputmode]]\" name$=\"[[name]]\" placeholder$=\"[[placeholder]]\" readonly$=\"[[readonly]]\" required$=\"[[required]]\" minlength$=\"[[minlength]]\" maxlength$=\"[[maxlength]]\" autocapitalize$=\"[[autocapitalize]]\" rows$=\"[[rows]]\" max-rows$=\"[[maxRows]]\" on-change=\"_onChange\"></iron-autogrow-textarea>\n\n      <template is=\"dom-if\" if=\"[[errorMessage]]\">\n        <paper-input-error aria-live=\"assertive\" slot=\"add-on\">[[errorMessage]]</paper-input-error>\n      </template>\n\n      <template is=\"dom-if\" if=\"[[charCounter]]\">\n        <paper-input-char-counter slot=\"add-on\"></paper-input-char-counter>\n      </template>\n\n    </paper-input-container>\n`,\n\n  is: 'paper-textarea',\n\n  behaviors: [\n    PaperInputBehavior,\n    IronFormElementBehavior,\n  ],\n\n  properties: {\n    _ariaLabelledBy: {\n      observer: '_ariaLabelledByChanged',\n      type: String,\n    },\n\n    _ariaDescribedBy: {\n      observer: '_ariaDescribedByChanged',\n      type: String,\n    },\n\n    value: {\n      // Required for the correct TypeScript type-generation\n      type: String,\n    },\n\n    /**\n     * The initial number of rows.\n     *\n     * @attribute rows\n     * @type {number}\n     * @default 1\n     */\n    rows: {\n      type: Number,\n      value: 1,\n    },\n\n    /**\n     * The maximum number of rows this element can grow to until it\n     * scrolls. 0 means no maximum.\n     *\n     * @attribute maxRows\n     * @type {number}\n     * @default 0\n     */\n    maxRows: {\n      type: Number,\n      value: 0,\n    },\n  },\n\n  /**\n   * @return {number}\n   */\n  get selectionStart() {\n    return this.$.input.textarea.selectionStart;\n  },\n\n  set selectionStart(start) {\n    this.$.input.textarea.selectionStart = start;\n  },\n\n  /**\n   * @return {number}\n   */\n  get selectionEnd() {\n    return this.$.input.textarea.selectionEnd;\n  },\n\n  set selectionEnd(end) {\n    this.$.input.textarea.selectionEnd = end;\n  },\n\n  _ariaLabelledByChanged: function(ariaLabelledBy) {\n    this._focusableElement.setAttribute('aria-labelledby', ariaLabelledBy);\n  },\n\n  _ariaDescribedByChanged: function(ariaDescribedBy) {\n    this._focusableElement.setAttribute('aria-describedby', ariaDescribedBy);\n  },\n\n  get _focusableElement() {\n    return this.inputElement.textarea;\n  }\n});\n"],"sourceRoot":""}